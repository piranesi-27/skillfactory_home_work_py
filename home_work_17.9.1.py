import random

sequence_numbers = input('Введите целые числа через пробел: ').split() # прием данных из консоли
list = [int(item) for item in sequence_numbers]
element = int(input('Введите любое число: ')) # запрашиваем число

# функция для сортировки

def quick_sort(list):
    if len(list) <= 1:
        return list
    else:
        x = list[random.randint(0, len(list) - 1)]  # случайное пороговое значение относительно которого идет разбиение
        low = [i for i in list if i < x] # определяем значения меньше порогового, заносим в список
        eql = [i for i in list if i == x] # сюда собираем значения равные пороговому
        high = [i for i in list if i > x] # здесь значения больше порогового
        list = quick_sort(low) + eql + quick_sort(high) # тут мы проходим функцией по нижним и верхним значениям...
        # ... объеденяем их со средними значениями посередине

    return list

list = quick_sort(list)

# опрделяем позицию элемента

def binary_search(list, element, left, right):
    try:
        if left > right:  # если левая граница превысила правую,
            return False  # значит элемент отсутствует

        middle = (right + left) // 2  # находимо середину
        if list[middle] == element:  # если элемент в середине,
            return middle  # возвращаем этот индекс
        elif element < list[middle]:  # если элемент меньше элемента в середине
            # рекурсивно ищем в левой половине
            return binary_search(list, element, left, middle - 1)
        else:  # иначе в правой
            return binary_search(list, element, middle + 1, right)
    except IndexError: # ловим ошибку выхождения сверх диапозона
        return 'Число выходит за диапазон списка, введите меньшее число.'

print(f'Отсортированный список: {list}')

# честно говоря этот код нашла в сети, долго над ним думала, но не все поняла. в комментариях далее мои предположения

if not binary_search(list, element, 0, len(list)): # я так понимаю тут мы задаем условие что если введенное число...
    #... есть в списке, то мы переходим к else в конце, а если нет, то проходим по условию внутри
    rI = min(list, key=lambda x: (abs(x - element), x))  # тут я так понимаю мы находим минимальный элемент в списке
    ind = list.index(rI) # тут определяем индекс этого элемента
    max_ind = ind + 1 # определяем индекс самого большого элемента
    min_ind = ind - 1 # определяем индекс самого маленького элемента
    if rI < element: # если минимальный элемент списка меньше введеного числа
        print(f'''В списке нет введенного элемента 
Ближайший меньший элемент: {rI}, его индекс: {ind} 
Ближайший больший элемент: {list[max_ind]} его индекс: {max_ind}''') # то выводим минимальный элемент и его индекс...
        #... и по индексу максимального элемента выводим наибольшее значение и сам индекс
    elif min_ind < 0: # если минимальный индекс меньше нуля
        print(f'''В списке нет введенного элемента
Ближайший больший элемент: {rI}, его индекс: {list.index(rI)}
В списке нет меньшего элемента''') # то выводим больший элемент и его индекс
    elif rI > element: # если минимальный элемент списка больше введеного числа
        print(f'''В списке нет введенного элемента
Ближайший больший элемент: {rI}, его индекс: {list.index(rI)}
Ближайший меньший элемент: {list[min_ind]}, его индекс: {min_ind}''') # то выводим больший элемент и его индекс...
        #... и по индексу минимального элемента выводим наибольшее значение и сам индекс
    elif list.index(rI) == 0: # !!! вот эта часть кода тут не срабатывает (хотя отдельно работает)!!!
        # если ввожу число, которое в отсортированном списке будет иметь индекс 0, то выводит сообщение В списке нет введенного элемента
        print(f'Индекс введенного элемента: {list.index(rI)}')
else:
    print(f'Индекс введенного элемента: {binary_search(list, element, 0, len(list))}')





